<!DOCTYPE html>
<html>
<head>
<style type="text/css">

	body { margin: 0; overflow: hidden; background: #fff; background: url(images/tealnoise.jpg); }

	div#canvas-wrap {
		position: absolute;
		width: 100%;
		height: 100%;
	}

</style>

<!-- libs -->
<script type="text/javascript" src="//code.jquery.com/jquery-1.10.2.min.js"></script>
<script type="text/javascript" src="three.min.js"></script>
<!--  -->
<script type="text/javascript" src="js/libs/MaskPass.js"></script>
<script type="text/javascript" src="js/libs/ShaderPass.js"></script>
<script type="text/javascript" src="js/libs/RenderPass.js"></script>
<script type="text/javascript" src="js/libs/EffectComposer.js"></script>

<script type="text/javascript">

/*
 *
 * Greets to everyone :)
 *
 * This basically just sets up a THREE.js scene with an empty line in the middle and then throws shaders at it.
 * The render callback modifies the vertices of the line by incrementing a couple constants in a parametric equation.
 * Try or using different parametric equations for x,y,z and you

 * The GLSL shaders are a bloom filter that applies a Guassian blur in two passes: horizontal and vertical
 * and a halftone filter (with scan lines) for extra awesome.
 *
 */

$( document ).ready( function () {

	var parent = $('#canvas-wrap');
	height = parent.height(),
	width = parent.width();

	var scene = new THREE.Scene(),
		camera = new THREE.PerspectiveCamera( 65, width / height, 0.1, 1000 ),
		renderer = new THREE.WebGLRenderer( { antialias : true, alpha : true } );
	camera.position.set(0,0,75);
	renderer.setSize( width, height );
	$( renderer.domElement ).appendTo( parent);

	var loadedShaders = new Event('loadedShaders');

	renderer.setClearColor( 0x000000, 0 );
	camera.position.set(0,0,250);
	camera.lookAt(new THREE.Vector3(0,0,0))

	var counter = 0, line;

	// wait til the shaders are loaded, then proceed
	window.addEventListener('loadedShaders',function(){

		// create a parametric line ===============================================================

		var material = new THREE.LineBasicMaterial({ color: 0xffffff, opacity :  0.5 });
		var x,y, geometry = new THREE.Geometry();

		// give it a bunch of empty vertices
		for (var i = 0; i < 360; i++) {
			geometry.vertices.push( new THREE.Vector3( x, y, 1) );
		};

		line = new THREE.Line(geometry,material);
		scene.add(line);
		camera.lookAt( line.position );

		initShaders();
		render()

	},false);

	// object to hold out shaders
	var shaders = { horizontalBlur : {}, verticalBlur : {}, halftone : {} };

	( function () {

		// assynchronously load all the shaders and dispatch the 'loadedShaders' event when complete
		$.when(

			$.get( 'http://jonbrennecke.github.io/demos/shaders/basic.vs', function ( vert ) {
				shaders.horizontalBlur.vertexShader = vert;
			}),

			$.get( 'http://jonbrennecke.github.io/demos/shaders/horizontalBlur.fs', function ( frag ) {
				shaders.horizontalBlur.fragmentShader = frag;
			}),

			$.get( 'http://jonbrennecke.github.io/demos/shaders/basic.fs', function ( vert ) {
				shaders.verticalBlur.vertexShader = vert;
			}),

			$.get( 'http://jonbrennecke.github.io/demos/shaders/verticalBlur.fs', function ( frag ) {
				shaders.verticalBlur.fragmentShader = frag;
			}),

			$.get( 'http://jonbrennecke.github.io/demos/shaders/basic.fs', function ( vert ) {
				shaders.halftone.vertexShader = vert;
			}),

			$.get( 'http://jonbrennecke.github.io/demos/shaders/halftone_scanlines.fs', function ( frag ) {
				shaders.halftone.fragmentShader = frag;
			})

		).then( function () {

			shaders.halftone.uniforms = {
				tSource1: { type: "t", value: 1, texture: null },
				tSource2: { type: "t", value: 1, texture: null }
			};

			shaders.horizontalBlur.uniforms = {
				tDiffuse: { type: "t", value: 0, texture: null },
				glomap: { type: "t", value: 1, texture: null }
			};

			shaders.verticalBlur.uniforms = {
				tDiffuse: { type: "t", value: 0, texture: null },
				glomap: { type: "t", value: 1, texture: null }
			};

			window.dispatchEvent( loadedShaders );
		});
	})(); // call immediately

	// these need to be defined in the larger scope so that the render loop can access them
	var effectComposer, composer;

	// initialize how the shaders will affect the scene
	function initShaders() {

		// 1.) the first EffectComposer just renders the scene--it's not very exciting.

		var renderTargetParameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat, stencilBufer: false },
		renderTargetBloom = new THREE.WebGLRenderTarget( width, height, renderTargetParameters ),
		renderEffectsPass = new THREE.RenderPass( scene, camera);

		effectComposer = new THREE.EffectComposer( renderer, renderTargetBloom );
		effectComposer.addPass( renderEffectsPass );

		// 2.) the second effects composer applies the effects onto the renderTarget generated as a result of the first EffectsComposer

		var renderTarget = new THREE.WebGLRenderTarget( width, height, renderTargetParameters );
		composer = new THREE.EffectComposer( renderer, renderTarget );
		var renderPass = new THREE.RenderPass( scene, camera );
		composer.addPass( renderPass );

		// horizontal pass for bloom filter
		shaders.horizontalBlur.uniforms.glomap.value = effectComposer.renderTarget2;
		var horizontalPass = new THREE.ShaderPass( shaders.horizontalBlur );
		composer.addPass( horizontalPass );

		// vertical pass for bloom filter
		shaders.verticalBlur.uniforms.glomap.value = composer.renderTarget1;
		var verticalPass = new THREE.ShaderPass( shaders.verticalBlur );
		composer.addPass( verticalPass );

		// halftone and scanlines
		shaders.halftone.uniforms.tSource1.value = effectComposer.renderTarget2;
		shaders.halftone.uniforms.tSource2.value = composer.renderTarget2;
		var blendPass = new THREE.ShaderPass( shaders.halftone );
		composer.addPass( blendPass );
		blendPass.renderToScreen = true; // make this the final pass
	};

	function render() {

		requestAnimationFrame( render );

		counter += 0.05;

		var x,y,z,t, scale = 50;
		var a = c = counter, b = d = 1, j = k = 1;

		for (var i = 0; i < 360; i++) {
			t =  i * Math.PI / 180; // convert to radians
			x = Math.cos( a * t ) - Math.pow( Math.cos( b * t ), j );
			y = Math.sin( a * t ) - Math.pow( Math.sin( d * t ), k );

			// modify the vertex positions
			line.geometry.vertices[i].set( scale * x, scale * y, 1 );
		};

		line.geometry.dynamic = true;
		line.geometry.verticesNeedUpdate = true; 

		effectComposer.render();
		composer.render();
	};


}); // end body onload

</script>
</head>
<body>

<div id="canvas-wrap"></div>

</body>
</html>